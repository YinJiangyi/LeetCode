> 持续更新

做题思路：

## **一、首先考虑递归**

​	树结构在数据结构中相对复杂，较多情况下，首要目标是先实现功能。所以除非面试官明确要求，首先实现一个递归可以实现目标的代码。大部分二叉树相关的题目都可以由**递归结合二叉树遍历**的逻辑实现。

### **几种常见的情况：**

1. **只需要递归过程，不需要维护变量**

   这种情况比较简单，一个递归函数即可实现，函数不需要有返回值，只需要执行打印等操作。

   如：按前/中/后序打印二叉树，

2. **通过递归实现某个变量的累计值并直接返回**

   这种情况和1相比，只需要将需要累加的返回值作为递归函数的返回结果即可。

   如：

3. **需要维护一个递归函数之外的全局变量**

   这种情况，需要维护一个全局变量，递归函数可以为void返回类型，只需在递归过程中实现改全局变量的更新逻辑即可。更新操作可能是对列表添加元素，也可能是比较大小维护一个最值。

   如：

4. **既需要计算累计变量，又需要全局变量**

   这种情况是最复杂的，往往要求输出一种全局最优的结果，但其中的每一种结果又涉及到累计的计算过程。

   > 例如：“二叉树的最大路径和”一题中，可以通过迭代的方式，基于子节点的最大路径和，来计算当前节点的最大路径和，但是二叉树的最大路径和对应的路径，不一定经过当前节点。所以一方面，迭代函数需要返回当前节点的单路径和，用于计算父节点的最大路径和；另一方面，还需要维护全局变量，记录各节点的最大路径和的最大值。

### **几种常见的结题思路**

1. 二叉树遍历

   需要熟悉掌握前序/中序/后序遍历的非递归写法（递归写法比较简单）

   **前中后序都是深度遍历，所以都可以用栈或递归实现，层序遍历是先进先出，所以用队列实现**

   > **前序遍历**：
   >
   > ​	一个栈
   >
   > ​	判断条件（!stack.isEmpty()）
   >
   > ​	每次打印top节点后，先后压入右节点和左节点。
   >
   > **中序遍历**：
   >
   > ​	一个栈+一个指针
   >
   > ​	判断条件（!stack.isEmpty() || curNode!=null）
   >
   > ​	每指向一个非空节点，先一路向左压栈 找到最左节点直到为null，然后弹栈，并指向右子树，循环。
   >
   > **后续遍历**：
   >
   > ​	两个栈+一个指针
   >
   > ​	判断条件（!stack.isEmpty() || curNode!=null）
   >
   > ​	一个栈存放标志位（访问状态，是第一次位于栈顶，还是已经压入过子节点之后第二次位于栈顶），先一路向左压栈找到最左节点并且标志位入0直到null。curNode==null时，如果标志栈栈顶为0，取stack.peek()，改标志位，压入右子节点和左子节点；如果标志栈栈顶为1，弹栈；
   >
   > **层序遍历**：
   >
   > ​	分层的层序遍历较复杂，需要在入下一层的节点之前，算栈的长度（本层节点个数），维护这个长度，每出一次队列，长度减一；当长度为零是，本层结束，存档并开始下一次循环。
   >
   > while(!queue.isEmpty())
   > 	size = queue.size()
   > 	while（size>0)
   > 		size --
   >
   > 这个模式使用较多，需牢记

2. 结合栈和队列

   >如：“锯齿形遍历”，标志位+栈

3. 二分法

   - 二叉搜索树：这种方法本质上是决策树的逻辑，将向量空间基于每层的节点进行划分

   > 例如：“验证搜索二叉树”一题中，了解搜索二叉树本质是对(-Long.<MAX_VALUE，+Long.MAX_VALUE)的数值范围的划分，那么验证的过程就是检查，每次划分后的数值范围和左右子节点的值是否存在矛盾。这样写递归就很清晰了。

   - 前序遍历和中序遍历的结合分析

### **易错点**

- “不一定过根节点”

  即常见情况的第四种：

  > **既需要计算累计变量，又需要全局变量**
  >
  > 这种情况是最复杂的，往往要求输出一种全局最优的结果，但其中的每一种结果又涉及到累计的计算过程。
  >
  > 如：“二叉树的直径”，“最大路径的和”，迭代函数返回当前节点需要迭代的值，并且更新全局变量。







